extends RigidBody3D
#Dice 
signal dice_stopped(value: int)
signal dice_rolling
signal dice_clicked(dice: RigidBody3D)

var is_rolling: bool = false
var is_selected: bool = false
var current_value: int = 0
var settle_timer: float = 0.0
var settle_threshold: float = 0.3  # Sekundy bez pohybu = zastaveno

# Vizu√°ln√≠ feedback - prstenec
var selection_ring: MeshInstance3D = null  # Reference na prstenec

# Definice stran kostky (norm√°lov√© vektory v local space)
var face_normals = {
	1: Vector3.UP,
	6: Vector3.DOWN,
	2: Vector3.FORWARD,
	5: Vector3.BACK,
	3: Vector3.LEFT,
	4: Vector3.RIGHT
}

func _ready():
	# Nastaven√≠ fyziky pro realistick√© chov√°n√≠
	contact_monitor = true
	max_contacts_reported = 4
	
	gravity_scale = 1.0 
	# Fyzik√°ln√≠ vlastnosti
	mass = 0.015  # Lehk√° kostka (15g)
	physics_material_override = PhysicsMaterial.new()
	physics_material_override.friction = 0.7  # T≈ôen√≠
	physics_material_override.bounce = 0.2  # Trochu poskakov√°n√≠
	
	linear_damp = 1.0  # Rychlej≈°√≠ zpomalen√≠ line√°rn√≠ho pohybu
	angular_damp = 2.0  # Rychlej≈°√≠ zpomalen√≠ rotace
	
	# Najdi prstenec vytvo≈ôen√Ω v editoru
	if has_node("SelectionRing"):
		selection_ring = $SelectionRing
		selection_ring.visible = false
	else:
		# Pokud neexistuje, vytvo≈ô ho programovƒõ
		create_selection_ring()

func show_and_activate():
	"""Zobraz kostku a aktivuj fyziku"""
	visible = true
	freeze = false

func create_selection_ring():
	"""Vytvo≈ô zlat√Ω prstenec pod kostkou"""
	selection_ring = MeshInstance3D.new()
	selection_ring.name = "SelectionRing"
	
	# Vytvo≈ô torus mesh (prstenec)
	var torus = TorusMesh.new()
	torus.inner_radius = 0.3
	torus.outer_radius = 0.5
	torus.rings = 32
	torus.ring_segments = 8
	
	selection_ring.mesh = torus
	
	# Materi√°l - zlat√Ω sv√≠t√≠c√≠
	var mat = StandardMaterial3D.new()
	mat.albedo_color = Color(1.0, 0.84, 0.0, 0.9)  # Zlat√°
	mat.emission_enabled = true
	mat.emission = Color(1.0, 0.84, 0.0, 0.5)
	mat.emission_energy_multiplier = 2.0
	mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
	
	selection_ring.material_override = mat
	
	# Pozice a rotace
	selection_ring.position = Vector3(0, -0.6, 0)  # Pod kostkou
	selection_ring.rotation_degrees = Vector3(0, 0, 90)  # Horizont√°lnƒõ
	
	selection_ring.visible = false
	
	add_child(selection_ring)
	print("‚ú® Prstenec vytvo≈ôen automaticky")

func _physics_process(delta):
	if is_rolling:
		# Kontrola rychlosti pro detekci zastaven√≠
		var velocity = linear_velocity.length() + angular_velocity.length()
		
		# Debug v√Ωpisy ka≈æd√Ωch 30 fram≈Ø
		if int(Engine.get_frames_drawn()) % 30 == 0:
			print("üé≤ [", name, "] Y=", "%.2f" % global_position.y, 
				  " velocity=", "%.2f" % velocity, 
				  " visible=", visible,
				  " freeze=", freeze)
		
		# ‚ö†Ô∏è OPRAVEN√Å bezpeƒçnostn√≠ kontrola
		if global_position.y < -5.0:
			print("‚ö†Ô∏è KOSTKA SPADLA MIMO SC√âNU! Y=", global_position.y)
			print("   Resetuji a zastavuji...")
			
			# Teleportuj zpƒõt nahoru
			global_position = Vector3(
				randf_range(-2, 2), 
				2.0,  # Ni≈æ≈°√≠ spawn
				randf_range(-2, 2)
			)
			
			# Reset fyziky
			linear_velocity = Vector3.ZERO
			angular_velocity = Vector3.ZERO
			freeze = true  # ‚ö†Ô∏è ZASTAV kostku!
			
			# Ukonƒçi kut√°len√≠
			stop_rolling()
			return
		
		# Detekce zastaven√≠ norm√°ln√≠m zp≈Øsobem
		if velocity < 0.05:
			settle_timer += delta
			if settle_timer >= settle_threshold:
				stop_rolling()
		else:
			settle_timer = 0.0
	
	# Udr≈æuj prstenec horizont√°ln√≠
	if selection_ring and selection_ring.visible:
		selection_ring.global_rotation = Vector3.ZERO

func start_rolling():
	"""Zaƒçni sledovat kut√°len√≠ (pro hod z kel√≠mku kde velocity je nastavena p≈ô√≠mo)"""
	is_rolling = true
	settle_timer = 0.0
	dice_rolling.emit()
	print("üé≤ Kostka zaƒçala kut√°len√≠ (external throw)")

func roll(impulse_strength: float = 3.0):
	"""Hoƒè kostkou s n√°hodn√Ωm impulzem - BEZ AWAIT!"""
	
	# Kontrola jestli kostka m≈Ø≈æe b√Ωt hozena
	if is_rolling:
		print("‚ö†Ô∏è Kostka ", name, " u≈æ se kut√°l√≠, ignoruji hod!")
		return
	
	# ‚ö†Ô∏è ZMƒöNA - pokud je frozen, prostƒõ odm√≠tni hod
	# Aktivace mus√≠ probƒõhnout P≈òED vol√°n√≠m roll()
	if freeze:
		print("‚ö†Ô∏è Kostka ", name, " je frozen, nelze hodit! Aktivuj ji nejd≈ô√≠v.")
		return
	
	# Debug kontrola
	print("üîç PRE-ROLL check kostky ", name, ":")
	print("   Global pos: ", global_transform.origin)
	print("   Velocity: ", linear_velocity)
	
	# Bezpeƒçnostn√≠ kontrola pozice
	if abs(global_transform.origin.x) > 20 or abs(global_transform.origin.z) > 20:
		print("üö´ ODM√çT√ÅM HOD - kostka je moc daleko!")
		global_transform.origin = Vector3(0, 2, 0)
		linear_velocity = Vector3.ZERO
		angular_velocity = Vector3.ZERO
		return
	
	# Bezpeƒçnostn√≠ kontrola velocity
	if abs(linear_velocity.y) > 0.5:
		print("‚ö†Ô∏è KOSTKA U≈Ω PAD√Å! Resetuji velocity...")
		linear_velocity = Vector3.ZERO
		angular_velocity = Vector3.ZERO
	
	is_rolling = true
	settle_timer = 0.0
	dice_rolling.emit()
	
	# Ujisti se ≈æe velocity je nulov√°
	linear_velocity = Vector3.ZERO
	angular_velocity = Vector3.ZERO
	
	# Smƒõr hodu
	var throw_direction = Vector3(
		randf_range(-1.0, 1.0),
		randf_range(0.3, 0.7),
		randf_range(-1.0, 1.0)
	).normalized()
	
	var random_impulse = throw_direction * impulse_strength
	
	# Rotace
	var random_torque = Vector3(
		randf_range(-10, 10),
		randf_range(-10, 10),
		randf_range(-10, 10)
	)
	
	apply_central_impulse(random_impulse)
	apply_torque_impulse(random_torque)
	
	print("‚úÖ Kostka ", name, " hodena smƒõrem: ", throw_direction, " silou: ", impulse_strength)

func stop_rolling():
	"""Zastav kostku a detekuj hodnotu"""
	is_rolling = false
	
	# Zastav pohyb
	linear_velocity = Vector3.ZERO
	angular_velocity = Vector3.ZERO
	
	# Detekuj, kter√° strana je naho≈ôe
	current_value = get_top_face()
	
	# Ujisti se, ≈æe hodnota je 1-6
	if current_value < 1 or current_value > 6:
		current_value = 1  # Fallback
		print("‚ö†Ô∏è Neplatn√° detekce, nastavuji na 1")
	
	dice_stopped.emit(current_value)
	
	print("Kostka uk√°zala: ", current_value)

func reset_for_reroll(new_local_position: Vector3):
	"""√öpln√Ω reset kostky pro rehod - z≈Østane frozen!"""
	
	# 1. ZASTAVEN√ç FYZIKY
	freeze = true  # Z≈Østane frozen!
	linear_velocity = Vector3.ZERO
	angular_velocity = Vector3.ZERO
	
	# 2. RESET STAVU
	is_rolling = false
	settle_timer = 0.0
	
	# 3. RESET TRANSFORMACE
	var parent_global = get_parent().global_transform.origin if get_parent() else Vector3.ZERO
	global_transform.origin = parent_global + new_local_position
	
	# 4. N√ÅHODN√Å ROTACE
	rotation = Vector3(
		randf_range(0, TAU),
		randf_range(0, TAU),
		randf_range(0, TAU)
	)
	
	# 5. ZOBRAZ kostku (ale nech frozen)
	visible = true
	
	print("üîÑ Kostka ", name, " resetov√°na (frozen) na: ", global_transform.origin)

func get_top_face() -> int:
	"""Zjisti, kter√° strana kostky je naho≈ôe"""
	var up_direction = Vector3.UP
	var best_face = 1
	var best_dot = -1.0
	
	# Transform norm√°lov√Ωch vektor≈Ø do world space a najdi nejbli≈æ≈°√≠ k UP
	for face_value in face_normals:
		var world_normal = global_transform.basis * face_normals[face_value]
		var dot = world_normal.dot(up_direction)
		
		if dot > best_dot:
			best_dot = dot
			best_face = face_value
	
	# Debug v√Ωpis pro testov√°n√≠
	print("Kostka rotace: ", rotation_degrees, " -> Detekovan√° hodnota: ", best_face, " (dot: ", best_dot, ")")
	
	# Pokud dot nen√≠ dostateƒçnƒõ velk√Ω, m≈Ø≈æeme m√≠t probl√©m
	if best_dot < 0.7:
		print("‚ö†Ô∏è Slab√° detekce (dot: ", best_dot, "), mo≈æn√° kostka nestoj√≠ stabilnƒõ")
	
	return best_face

func get_value() -> int:
	"""Vra≈• aktu√°ln√≠ hodnotu kostky"""
	return current_value

func is_dice_rolling() -> bool:
	"""Kontrola, zda se kostka je≈°tƒõ kut√°l√≠"""
	return is_rolling

func set_face(value: int):
	"""Nastav kostku na konkr√©tn√≠ hodnotu (pro testov√°n√≠)"""
	if value < 1 or value > 6:
		push_error("Neplatn√° hodnota kostky: " + str(value))
		return
	
	# Nastav rotaci podle po≈æadovan√© strany
	match value:
		1:
			rotation = Vector3.ZERO
		2:
			rotation = Vector3(0, 0, -PI/2)
		3:
			rotation = Vector3(PI/2, 0, 0)
		4:
			rotation = Vector3(-PI/2, 0, 0)
		5:
			rotation = Vector3(0, 0, PI/2)
		6:
			rotation = Vector3(PI, 0, 0)
	
	current_value = value

func set_selected(selected: bool) -> void:
	"""Zobraz/skryj prstenec pod kostkou"""
	is_selected = selected
	
	if selection_ring:
		selection_ring.visible = selected
		print("üîî Prstenec ", "ZOBRAZIT" if selected else "SKR√ùT")

func _input_event(_camera: Camera3D, event: InputEvent, _position: Vector3, _normal: Vector3, _shape_idx: int):
	"""Detekce kliknut√≠ na kostku"""
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			if not is_rolling:
				dice_clicked.emit(self)  # Emitujeme sign√°l p≈ôi kliknut√≠
